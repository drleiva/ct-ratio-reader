<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Strip Ratio Reader (Private)</title>
  <style>
    :root { --card:#fff; --border:#d8d8d8; --shadow:0 1px 3px rgba(0,0,0,.1); }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin:0; padding:14px;
      background:#f7f7f7; color:#111;
    }
    h2{ margin:0 0 10px 0; font-size:20px; }
    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:10px;
      box-shadow:var(--shadow);
      padding:12px;
      width:min(980px, 100%);
    }
    .small{ font-size:13px; color:#444; line-height:1.35; }
    button, select{
      padding:10px 12px; font-size:15px;
      border-radius:10px; border:1px solid var(--border);
      background:#fff; cursor:pointer;
    }
    button.primary{ background:#111; color:#fff; border-color:#111; }
    button:disabled, select:disabled{ opacity:.5; cursor:not-allowed; }
    canvas{
      width:100%;
      border:1px solid var(--border);
      border-radius:10px;
      touch-action:none;
      background:#fff;
      display:block;
    }
    .grid{ display:grid; grid-template-columns: 1fr; gap:12px; }
    .results{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap:10px;
      margin-top:10px;
    }
    .metric{
      border:1px solid var(--border);
      border-radius:10px;
      padding:10px;
      background:#fff;
    }
    .metric b{ display:block; font-size:13px; color:#444; }
    .metric span{ font-size:20px; font-weight:700; }
    .hint{
      margin-top:10px;
      padding:10px;
      border-radius:10px;
      background:#fff;
      border:1px dashed var(--border);
      color:#333;
      font-size:13px;
      line-height:1.4;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding:1px 6px;
      border:1px solid var(--border);
      border-radius:6px;
      background:#fafafa;
    }
    label{ display:flex; align-items:center; gap:8px; }
  </style>
</head>

<body>
  <div class="card">
    <h2>Strip Ratio Reader (Private)</h2>
    <div class="row">
      <input type="file" accept="image/*" id="fileInput">

      <button class="primary" id="btnCompute" disabled>Compute</button>
      <button id="btnReset" disabled>Reset ROI</button>
      <button id="btnSwap" disabled>Swap T ↔ C</button>

      <label class="small" title="Choose how the ratio is displayed">
        Ratio:
        <select id="ratioSelect" disabled>
          <option value="TC" selected>T/C</option>
          <option value="CT">C/T</option>
        </select>
      </label>

      <label class="small" title="Line finding mode">
        Mode:
        <select id="modeSelect" disabled>
          <option value="auto" selected>Auto-detect 2 lines</option>
          <option value="manual">Manual (ROI only)</option>
        </select>
      </label>
    </div>

    <div class="small" style="margin-top:8px;">
      Drag the red box over the test window. Use the <b>corner handle</b> to resize. Then click <b>Compute</b>.
    </div>
  </div>

  <div class="card grid" style="margin-top:12px;">
    <canvas id="canvas"></canvas>

    <div class="results" id="results" style="display:none;">
      <div class="metric">
        <b id="mRatioLabel">Ratio</b>
        <span id="mRatio">—</span>
        <div class="small" id="mRatioFormula">—</div>
      </div>
      <div class="metric">
        <b>ΔT (BG − T)</b>
        <span id="mDT">—</span>
        <div class="small">Bigger = darker test line</div>
      </div>
      <div class="metric">
        <b>ΔC (BG − C)</b>
        <span id="mDC">—</span>
        <div class="small">Control contrast reference</div>
      </div>
      <div class="metric">
        <b id="mRIODLabel">RIOD-style</b>
        <span id="mRIOD">—</span>
        <div class="small" id="mRIODFormula">—</div>
      </div>
    </div>

    <div class="hint" id="output">
      <b>Tips</b><br>
      • If the app mixes up which line is control vs test, click <span class="kbd">Swap T ↔ C</span>.<br>
      • Keep ROI tight around both lines for best results.
    </div>
  </div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d", { willReadFrequently: true });

const fileInput = document.getElementById("fileInput");
const btnCompute = document.getElementById("btnCompute");
const btnReset = document.getElementById("btnReset");
const btnSwap = document.getElementById("btnSwap");
const modeSelect = document.getElementById("modeSelect");
const ratioSelect = document.getElementById("ratioSelect");

const output = document.getElementById("output");
const results = document.getElementById("results");

const mRatio = document.getElementById("mRatio");
const mDT = document.getElementById("mDT");
const mDC = document.getElementById("mDC");
const mRIOD = document.getElementById("mRIOD");

const mRatioLabel = document.getElementById("mRatioLabel");
const mRatioFormula = document.getElementById("mRatioFormula");
const mRIODLabel = document.getElementById("mRIODLabel");
const mRIODFormula = document.getElementById("mRIODFormula");

let img = new Image();
let hasImage = false;

// ROI with resize handle (bottom-right)
let roi = { x: 50, y: 50, w: 240, h: 140 };
let dragMode = null; // "move" | "resize"
let dragOffset = { x: 0, y: 0 };

// Store state from last compute so changing toggle updates instantly
let lastComputed = null; // { cY,tY, gray,w,h,x1,x2,BG,C,T,dT,dC }

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

function updateLabels(){
  const mode = ratioSelect.value; // "TC" or "CT"
  if (mode === "TC") {
    mRatioLabel.textContent = "T/C ratio (BG-normalized)";
    mRatioFormula.textContent = "Computed as (BG−T)/(BG−C)";
    mRIODLabel.textContent = "RIOD-style (log contrast, T/C)";
    mRIODFormula.textContent = "log(BG/T) ÷ log(BG/C)";
  } else {
    mRatioLabel.textContent = "C/T ratio (BG-normalized)";
    mRatioFormula.textContent = "Computed as (BG−C)/(BG−T)";
    mRIODLabel.textContent = "RIOD-style (log contrast, C/T)";
    mRIODFormula.textContent = "log(BG/C) ÷ log(BG/T)";
  }
}

ratioSelect.addEventListener("change", () => {
  updateLabels();
  if (lastComputed) renderMetricsFromLast();
});

fileInput.addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  img = new Image();
  img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;
    hasImage = true;

    roi = {
      x: img.width * 0.18,
      y: img.height * 0.35,
      w: img.width * 0.64,
      h: img.height * 0.25
    };

    btnCompute.disabled = false;
    btnReset.disabled = false;
    btnSwap.disabled = true;
    modeSelect.disabled = false;
    ratioSelect.disabled = false;

    lastComputed = null;
    results.style.display = "none";
    updateLabels();
    output.innerHTML = "<b>Loaded.</b> Position ROI over the test window, then click <b>Compute</b>.";
    draw();
  };

  img.src = URL.createObjectURL(file);
});

btnReset.addEventListener("click", () => {
  if (!hasImage) return;
  roi = {
    x: img.width * 0.18,
    y: img.height * 0.35,
    w: img.width * 0.64,
    h: img.height * 0.25
  };
  lastComputed = null;
  btnSwap.disabled = true;
  results.style.display = "none";
  output.innerHTML = "ROI reset. Reposition and compute again.";
  draw();
});

btnSwap.addEventListener("click", () => {
  if (!lastComputed) return;
  const tmp = lastComputed.tY;
  lastComputed.tY = lastComputed.cY;
  lastComputed.cY = tmp;
  // recompute C/T metrics from the same grayscale buffer
  computeWithKnownLines(lastComputed.cY, lastComputed.tY, lastComputed.gray, lastComputed.w, lastComputed.h, lastComputed.x1, lastComputed.x2);
});

btnCompute.addEventListener("click", () => computeRatio());

function draw() {
  if (!hasImage) {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    return;
  }
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img,0,0);

  ctx.save();
  ctx.strokeStyle = "red";
  ctx.lineWidth = Math.max(2, Math.round(Math.min(canvas.width, canvas.height) / 300));
  ctx.strokeRect(roi.x, roi.y, roi.w, roi.h);

  const hs = Math.max(10, Math.round(Math.min(canvas.width, canvas.height) / 60));
  ctx.fillStyle = "red";
  ctx.fillRect(roi.x + roi.w - hs, roi.y + roi.h - hs, hs, hs);
  ctx.restore();
}

function canvasToImageCoords(clientX, clientY){
  const r = canvas.getBoundingClientRect();
  const x = (clientX - r.left) * (canvas.width / r.width);
  const y = (clientY - r.top) * (canvas.height / r.height);
  return { x, y };
}

function isInResizeHandle(x, y){
  const hs = Math.max(10, Math.round(Math.min(canvas.width, canvas.height) / 60));
  const rx = roi.x + roi.w - hs;
  const ry = roi.y + roi.h - hs;
  return x >= rx && x <= rx + hs && y >= ry && y <= ry + hs;
}

function isInROI(x, y){
  return x >= roi.x && x <= roi.x + roi.w && y >= roi.y && y <= roi.y + roi.h;
}

canvas.addEventListener("pointerdown", e => {
  if (!hasImage) return;
  const p = canvasToImageCoords(e.clientX, e.clientY);

  if (isInResizeHandle(p.x, p.y)) {
    dragMode = "resize";
    canvas.setPointerCapture(e.pointerId);
    return;
  }
  if (isInROI(p.x, p.y)) {
    dragMode = "move";
    dragOffset.x = p.x - roi.x;
    dragOffset.y = p.y - roi.y;
    canvas.setPointerCapture(e.pointerId);
  }
});

canvas.addEventListener("pointermove", e => {
  if (!dragMode) return;
  const p = canvasToImageCoords(e.clientX, e.clientY);

  if (dragMode === "move") {
    roi.x = clamp(p.x - dragOffset.x, 0, canvas.width - roi.w);
    roi.y = clamp(p.y - dragOffset.y, 0, canvas.height - roi.h);
  } else if (dragMode === "resize") {
    const minW = Math.max(40, canvas.width * 0.08);
    const minH = Math.max(30, canvas.height * 0.06);
    roi.w = clamp(p.x - roi.x, minW, canvas.width - roi.x);
    roi.h = clamp(p.y - roi.y, minH, canvas.height - roi.y);
  }
  draw();
});

canvas.addEventListener("pointerup", () => dragMode = null);
canvas.addEventListener("pointercancel", () => dragMode = null);

function computeRatio() {
  if (!hasImage) return;

  const rx = Math.round(roi.x), ry = Math.round(roi.y);
  const rw = Math.round(roi.w), rh = Math.round(roi.h);
  if (rw < 10 || rh < 10) return;

  const roiData = ctx.getImageData(rx, ry, rw, rh);
  const w = roiData.width;
  const h = roiData.height;
  const d = roiData.data;

  // Grayscale luminance
  const gray = new Float32Array(w*h);
  for (let i=0; i<w*h; i++) {
    const r = d[i*4], g = d[i*4+1], b = d[i*4+2];
    gray[i] = 0.299*r + 0.587*g + 0.114*b;
  }

  const x1 = Math.floor(w * 0.18);
  const x2 = Math.floor(w * 0.82);

  // Darkness profile by row
  const prof = new Float32Array(h);
  for (let y=0; y<h; y++){
    let sum=0, n=0;
    for (let x=x1; x<x2; x++){
      sum += gray[y*w + x]; n++;
    }
    prof[y] = 255 - (sum/n);
  }

  // Smooth
  const sm = new Float32Array(h);
  const k = 2;
  for (let y=0; y<h; y++){
    let s=0, n=0;
    for (let yy=y-k; yy<=y+k; yy++){
      if (yy>=0 && yy<h){ s += prof[yy]; n++; }
    }
    sm[y] = s/n;
  }

  // Peaks
  let peaks = [];
  for (let y=1; y<h-1; y++){
    if (sm[y] > sm[y-1] && sm[y] > sm[y+1]) peaks.push({ y, v: sm[y] });
  }
  peaks.sort((a,b)=>b.v-a.v);

  if (peaks.length < 2) {
    results.style.display = "none";
    output.innerHTML = "Could not detect two line peaks inside ROI. Try resizing ROI tighter.";
    return;
  }

  // pick two peaks with separation
  const minSep = Math.max(8, Math.round(h * 0.10));
  let p1 = peaks[0];
  let p2 = null;
  for (let i=1; i<peaks.length; i++){
    if (Math.abs(peaks[i].y - p1.y) >= minSep) { p2 = peaks[i]; break; }
  }
  if (!p2) {
    results.style.display = "none";
    output.innerHTML = "Detected peaks are too close together. Try a taller ROI that includes both lines.";
    return;
  }

  // Convention: control is upper in ROI
  let cY = Math.min(p1.y, p2.y);
  let tY = Math.max(p1.y, p2.y);

  btnSwap.disabled = false;
  computeWithKnownLines(cY, tY, gray, w, h, x1, x2);
}

function computeWithKnownLines(cY, tY, gray, w, h, x1, x2){
  function meanBand(yStart, yEnd){
    let sum=0, n=0;
    for (let y=yStart; y<=yEnd; y++){
      for (let x=x1; x<x2; x++){
        sum += gray[y*w + x]; n++;
      }
    }
    return sum / n;
  }

  // BG estimate from top & bottom of ROI
  const topEnd = Math.max(0, Math.floor(h*0.15)-1);
  const botStart = Math.min(h-1, Math.floor(h*0.85));
  const BG = (meanBand(0, topEnd) + meanBand(botStart, h-1)) / 2;

  function lineMean(yc){
    const half = Math.max(2, Math.round(h * 0.03)); // ~3% of ROI height
    const ys = clamp(yc - half, 0, h-1);
    const ye = clamp(yc + half, 0, h-1);
    return meanBand(ys, ye);
  }

  const C = lineMean(cY);
  const T = lineMean(tY);

  const dT = Math.max(0, BG - T);
  const dC = Math.max(0, BG - C);

  lastComputed = { cY, tY, gray, w, h, x1, x2, BG, C, T, dT, dC };

  renderMetricsFromLast();
}

function renderMetricsFromLast(){
  const { BG, C, T, dT, dC } = lastComputed;
  const eps = 1e-3;

  let ratio, riod;
  if (ratioSelect.value === "TC") {
    ratio = (dC > 1e-6) ? (dT / dC) : 0;
    riod  = (Math.log((BG+eps)/(T+eps))) / (Math.log((BG+eps)/(C+eps)));
  } else {
    ratio = (dT > 1e-6) ? (dC / dT) : 0;
    riod  = (Math.log((BG+eps)/(C+eps))) / (Math.log((BG+eps)/(T+eps)));
  }

  results.style.display = "grid";
  mRatio.textContent = ratio.toFixed(2);
  mDT.textContent = dT.toFixed(1);
  mDC.textContent = dC.toFixed(1);
  mRIOD.textContent = isFinite(riod) ? riod.toFixed(2) : "—";

  output.innerHTML =
    `<b>Done.</b> Computed from grayscale intensity inside ROI.<br>` +
    `<span class="small">If the ratio seems inverted, click <span class="kbd">Swap T ↔ C</span> or change the Ratio toggle.</span>`;
}

// init labels
updateLabels();
</script>
</body>
</html>
