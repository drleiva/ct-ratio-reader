<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>C/T Ratio Reader (Private)</title>
<style>
  body { font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 12px; background: #f7f7f7; }
  h2 { margin-top: 0; }
  canvas { max-width: 100%; border: 1px solid #ccc; touch-action: none; background: white; }
  .controls { margin: 10px 0; }
  button { padding: 10px 14px; font-size: 16px; margin-right: 8px; }
  .result { margin-top: 12px; padding: 10px; background: #fff; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,.1); }
</style>
</head>

<body>
<h2>C/T Ratio Reader (Private)</h2>

<input type="file" accept="image/*" id="fileInput">

<canvas id="canvas"></canvas>

<div class="controls">
  <button onclick="computeRatio()">Compute C/T Ratio</button>
</div>

<div class="result" id="output">
  Load an image, move the red box over the test window, then tap “Compute”.
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const fileInput = document.getElementById("fileInput");
const output = document.getElementById("output");

let img = new Image();

// Movable ROI box
let roi = { x: 50, y: 50, w: 200, h: 120 };
let dragging = false;

fileInput.addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (!file) return;

  img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;

    // Reasonable default ROI centered-ish
    roi = {
      x: img.width * 0.2,
      y: img.height * 0.3,
      w: img.width * 0.6,
      h: img.height * 0.25
    };
    draw();
  };

  img.src = URL.createObjectURL(file);
});

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0);

  // Draw ROI box
  ctx.strokeStyle = "red";
  ctx.lineWidth = 3;
  ctx.strokeRect(roi.x, roi.y, roi.w, roi.h);
}

// Pointer events for dragging ROI box
canvas.addEventListener("pointerdown", (e) => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;

  if (x > roi.x && x < roi.x + roi.w && y > roi.y && y < roi.y + roi.h) {
    dragging = true;
    canvas.setPointerCapture(e.pointerId);
  }
});

canvas.addEventListener("pointermove", (e) => {
  if (!dragging) return;

  const r = canvas.getBoundingClientRect();
  roi.x = e.clientX - r.left - roi.w / 2;
  roi.y = e.clientY - r.top - roi.h / 2;

  roi.x = Math.max(0, Math.min(roi.x, canvas.width - roi.w));
  roi.y = Math.max(0, Math.min(roi.y, canvas.height - roi.h));

  draw();
});

canvas.addEventListener("pointerup", () => dragging = false);
canvas.addEventListener("pointercancel", () => dragging = false);

function computeRatio() {
  if (!img.src) return;

  // Extract ROI pixel data
  const roiData = ctx.getImageData(roi.x, roi.y, roi.w, roi.h);
  const w = roiData.width;
  const h = roiData.height;
  const d = roiData.data;

  // Convert ROI to grayscale array (0..255)
  const gray = new Array(w * h);
  for (let i = 0; i < w * h; i++) {
    const r = d[i * 4], g = d[i * 4 + 1], b = d[i * 4 + 2];
    gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;
  }

  // Build row darkness profile (higher means darker band)
  let darkness = new Array(h).fill(0);
  const xStart = Math.floor(w * 0.2);
  const xEnd   = Math.floor(w * 0.8);

  for (let y = 0; y < h; y++) {
    let sum = 0, n = 0;
    for (let x = xStart; x < xEnd; x++) {
      sum += gray[y * w + x];
      n++;
    }
    const mean = sum / Math.max(1, n);
    darkness[y] = 255 - mean;
  }

  // Smooth the profile (simple 5-pt moving average)
  for (let i = 2; i < h - 2; i++) {
    darkness[i] = (darkness[i-2] + darkness[i-1] + darkness[i] + darkness[i+1] + darkness[i+2]) / 5;
  }

  // Find local maxima candidates
  let candidates = [];
  for (let y = 1; y < h - 1; y++) {
    if (darkness[y] > darkness[y - 1] && darkness[y] > darkness[y + 1]) {
      candidates.push({ y, v: darkness[y] });
    }
  }
  candidates.sort((a, b) => b.v - a.v);

  if (candidates.length < 2) {
    output.innerHTML = "Could not detect two lines. Try a tighter crop and better lighting.";
    return;
  }

  // Pick top two peaks; if too close, search next
  const minSep = Math.max(10, Math.floor(h / 12));
  let peaks = [];
  for (const c of candidates) {
    if (peaks.every(p => Math.abs(p.y - c.y) >= minSep)) peaks.push(c);
    if (peaks.length === 2) break;
  }
  if (peaks.length < 2) {
    output.innerHTML = "Detected peaks were too close. Try adjusting the crop box.";
    return;
  }

  // Assign C and T by vertical order (you can swap in code if your strip is opposite)
  const cY = Math.min(peaks[0].y, peaks[1].y);
  const tY = Math.max(peaks[0].y, peaks[1].y);

  // Mean intensity in a small band around a peak
  function bandMean(centerY) {
    const halfBand = 3;
    let sum = 0, n = 0;
    for (let y = Math.max(0, centerY - halfBand); y <= Math.min(h - 1, centerY + halfBand); y++) {
      for (let x = xStart; x < xEnd; x++) {
        sum += gray[y * w + x];
        n++;
      }
    }
    return sum / Math.max(1, n);
  }

  const T = bandMean(tY);
  const C = bandMean(cY);

  // Background mean from top and bottom margins
  function bgMean() {
    let sum = 0, n = 0;
    const topEnd = Math.floor(h * 0.15);
    const botStart = Math.floor(h * 0.85);

    for (let y = 0; y < topEnd; y++) {
      for (let x = xStart; x < xEnd; x++) { sum += gray[y*w + x]; n++; }
    }
    for (let y = botStart; y < h; y++) {
      for (let x = xStart; x < xEnd; x++) { sum += gray[y*w + x]; n++; }
    }
    return sum / Math.max(1, n);
  }

  const BG = bgMean();

  // Darkness relative to background (larger = darker line)
  const dT = Math.max(0, BG - T);
  const dC = Math.max(0, BG - C);

  // Compute C/T ratio
  const ratio = dT > 1 ? (dC / dT) : 0;

  output.innerHTML =
    `<b>C/T ratio:</b> ${ratio.toFixed(2)}<br>
     <small>(C darker = higher ratio). Detected C@row=${cY}, T@row=${tY}</small>`;
}
</script>
</body>
</html>
